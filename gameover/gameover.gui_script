local TouchFb = require("modules.animation")
local Prompt = require("modules.prompt")

local exit_dialogue_nodes = {'exit_dialogue_box', 'exit_text', 'yes_exit', 'no_exit', 'yes','no'}	
local menu_nodes = {'gameover', "_resume", "_restart", "_sound",
"_menu", 'resume', 'restart', 'sound', 'menu', 'show_ad', 'ad_text', "board", "brakes", "lives", "coins",
"money", "challenge_txt", "challenge", "_chal_but", "chal_but", "challenge_reward", "score", "best"}
local chal_prompt_nodes = {"chal_dialogue_box", "chal_prompt", "yes_chal", "yes1", "no_chal", "no1"}
local is_exit_prompt_active
local is_chal_prompt_active


local req_challenge = function()
	msg.post("main:/main#challenges", "challenges_requested")
end

function init(self)
	msg.post(analyzer, "gameover")
	req_challenge()
	Prompt.prompt(exit_dialogue_nodes, menu_nodes)
	Prompt.prompt(chal_prompt_nodes, menu_nodes)
	is_exit_prompt_active = false
	is_chal_prompt_active = false
	msg.post("@render:", "clear_color", { color = vmath.vector4(1, 1, 1, 0) } )
	msg.post("/gameover#ended", "play_sound", {delay = 0, gain = 1})
	msg.post(".", "acquire_input_focus")
	--notify the controller script of the game over
	msg.post("level:/controller#controller", "streaks_needed")
	-- set the score
	local score_id = gui.get_node("score")
	gui.set_text(score_id, score)
	-- display the highscore
	if score > highscore then

	else

	end
	local best_id = gui.get_node('best')
	gui.set_text(best_id, "best\n"..tostring(highscore))
	local m = gui.get_node("money")
	gui.set_text(m, "$"..tostring(money))
	local b = gui.get_node("brakes")
	gui.set_text(b, "BRAKES\n"..tostring(brakes))
	local l = gui.get_node("lives")
	gui.set_text(l, "LIVES\n"..tostring(lives))
	local c = gui.get_node("coins")
	gui.set_text(c, "COINS\n"..tostring(coins))
end

function final(self)
	msg.post(".", "release_input_focus")
end

local button_tapped = nil

local chal_status

local function handle_input()
	if button_tapped == 'resume' then 
		msg.post(main, 'resume', {col = "gameover"})-- tells the controller script which collection to unload when resuming
		lives = lives - 1
		msg.post(ANALYZER, 'respawn_used')
	elseif button_tapped == 'show_ad' then
		msg.post("main:/main#main", "show_ad", {id = "gameover:/gameover#gameover"})
	elseif button_tapped == 'restart' then
		msg.post(main, 'restart', {col = "gameover"})-- tells the controller script which collection to unload when restarting	
		msg.post(analyzer, "game_restarted")
	elseif button_tapped == 'sound' then
		msg.post("main:/main#main", "sound")
	elseif button_tapped == 'menu' then
		Prompt.prompt(menu_nodes, exit_dialogue_nodes)
		is_exit_prompt_active = true
	elseif button_tapped == 'chal_but' then
		if chal_status then
			chal_changes_allowed = 2
			--give reward
			msg.post("main:/main#challenges", "give_reward")
			msg.post("main:/main#challenges", "change_challenge")
			timer.delay(0.001, false, req_challenge)
		else
			Prompt.prompt(menu_nodes, chal_prompt_nodes)
			local node = gui.get_node("chal_prompt")
			local text
			if chal_changes_allowed > 0 then
				text = "CHANGE CHALLENGE\nChanges left\n"..chal_changes_allowed.."\n Are you sure ?"
			else
				text = "CHANGE CHALLENGE\nCoins left\n"..coins.."\nit will cost 2 COINS ?"
			end
			gui.set_text(node, text)
			is_chal_prompt_active = true
		end

	elseif button_tapped == 'yes' then
		msg.post(main, 'return_2_menu', {col = "gameover"})-- tells the controller script which collection to unload when returning to menu
	elseif button_tapped == 'no' then
		Prompt.prompt(exit_dialogue_nodes, menu_nodes)
		is_exit_prompt_active = false
	elseif button_tapped == 'yes_chal' then
		if chal_changes_allowed > 0 then
			chal_changes_allowed = chal_changes_allowed - 1
			msg.post("main:/main#challenges", "change_challenge")
			timer.delay(0.001, false, req_challenge)
		elseif coins > 0 then
			coins = coins - 2 --the player can change the challenge for two coins
			local c = gui.get_node("coins")
			gui.set_text(c, "COINS\n"..tostring(coins))		
			msg.post("main:/main#challenges", "change_challenge")
			timer.delay(0.001, false, req_challenge)
		end
		Prompt.prompt(chal_prompt_nodes, menu_nodes)
		is_chal_prompt_active = false
	elseif button_tapped == 'no_chal' then
		Prompt.prompt(chal_prompt_nodes, menu_nodes)
		is_chal_prompt_active = false	
	end
end


-- message ids
local msg_challenges = hash("challenges")
local landmark = hash("landmark")
local msg_completed = hash("completed")
local msg_chal = hash("chal")
local msg_chal_reward = hash("chal_reward")

function on_message(self, message_id, message, sender)
	if message_id == msg_chal then
		local node = gui.get_node("challenge")
		gui.set_text(node, message.c)
		chal_status = message.status
		node = gui.get_node("chal_but") -- I reused the node variable to accomodate the text on the challenge button
		if chal_status then
			gui.set_text(node, "TAP TO GET\nREWARD")
		else
			gui.set_text(node, "CHANGE\nCHALLENGE")
		end
		node = gui.get_node("challenge_reward")
		local chal_reward = message.reward * NumOfColorsPicked
		gui.set_text(node, "REWARD\n$"..chal_reward)
	elseif message_id == msg_completed then
		msg.post("/gameover#reward", "play_sound", {delay = 0, gain = 1})
		lives = lives + 1
		-- adjust the lives
		local lives_id = gui.get_node("lives")
		gui.set_text(lives_id, "LIVES"..tostring(lives))
	elseif message_id == msg_chal_reward then
		local m = gui.get_node("money")
		gui.set_text(m, "$"..tostring(money))
	end
end

-- touch_ids
local touch = hash("touch")
local back = hash("back")

function on_input(self, action_id, action)
	if action_id == touch and action.released then
		local _resume  = gui.get_node('_resume')
		local _restart = gui.get_node('_restart')
		local _sound = gui.get_node('_sound')
		local _menu = gui.get_node('_menu')
		local chal_but = gui.get_node("_chal_but")
		local show_ad = gui.get_node('show_ad')
		local yes = gui.get_node("yes_exit")
		local no = gui.get_node("no_exit")
		local yes_chal = gui.get_node("yes_chal")
		local no_chal = gui.get_node("no_chal")
		if is_exit_prompt_active == false and is_chal_prompt_active == false then
			if gui.pick_node(_resume, action.x, action.y) and lives > 0 and is_exit_prompt_active == false then 
				button_tapped = 'resume'
				TouchFb.touch_feedback(_resume, handle_input)
			elseif gui.pick_node(show_ad, action.x, action.y) and is_exit_prompt_active == false then
				button_tapped = 'show_ad'
				TouchFb.touch_feedback(show_ad, handle_input)
			elseif gui.pick_node(_restart, action.x, action.y) and is_exit_prompt_active == false then
				button_tapped = 'restart'
				TouchFb.touch_feedback(_restart, handle_input)
			elseif gui.pick_node(_sound, action.x, action.y) and is_exit_prompt_active == false then
				button_tapped = 'sound'
				TouchFb.touch_feedback(_sound, handle_input)
			elseif gui.pick_node(_menu, action.x, action.y) and is_exit_prompt_active == false then
				button_tapped = 'menu'
				TouchFb.touch_feedback(_menu, handle_input)
			elseif gui.pick_node(chal_but, action.x, action.y) then
				button_tapped = 'chal_but'
				TouchFb.touch_feedback(chal_but, handle_input)
			end
		elseif is_exit_prompt_active then
			if gui.pick_node(yes, action.x, action.y) then
				button_tapped = 'yes'
				TouchFb.touch_feedback(yes, handle_input)
			elseif gui.pick_node(no, action.x, action.y) then
				button_tapped = 'no'
				TouchFb.touch_feedback(no, handle_input)
			end
		elseif is_chal_prompt_active then
			if gui.pick_node(yes_chal, action.x, action.y) then
				button_tapped = 'yes_chal'
				TouchFb.touch_feedback(yes_chal, handle_input)
			elseif gui.pick_node(no_chal, action.x, action.y) then
				button_tapped = 'no_chal'
				TouchFb.touch_feedback(no_chal , handle_input)
			end
		end
	elseif action_id == back then
		if is_exit_prompt_active == false then
			button_tapped = 'exit'
			TouchFb.touch_feedback(exit, handle_input)
		else
			Prompt.prompt(chal_prompt_nodes, menu_nodes)
			is_chal_prompt_active = false
		end
	end
end