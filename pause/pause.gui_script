local TouchFb = require("modules.animation")

local function set_currency()
	local gold_text = gui.get_node("gold")
	local diamonds_text = gui.get_node("diamonds")
	gui.set_text(gold_text, gold)
	gui.set_text(diamonds_text, diamonds)
end
local function animate_button(node)
	gui.animate(node, "rotation.z", 1, gui.EASING_OUTSINE, 5, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
end

local function animate_menu(nodes)
	for i in ipairs(nodes) do
		animate_button(nodes[i])
	end
end

local node_table = {}-- each gui script has its own node_table

local function get_nodes(string_table)
	for i in ipairs(string_table) do
		table.insert(node_table, gui.get_node(string_table[i]))
	end
end

local is_exit_prompt_active
local function hide_exit_prompt()
	local nodes = {'exit_dialogue_box', 'exit_text', 'yes_exit', 'no_exit', 'yes','no'}	
	for i in ipairs(nodes) do
		local node = gui.get_node(nodes[i])
		gui.set_enabled(node, false)
	end
	local node_strings = {'paused', 's_chal', "h_chal",'gold', 'diamonds', "_resume", "_restart", "_sound",
	"_menu", 'resume', 'restart', 'sound', 'menu', 'show_ad', 'ad_text'}
	for i in ipairs(node_strings) do
		local node = gui.get_node(node_strings[i])
		gui.set_enabled(node, true)
	end
	is_exit_prompt_active = false
end

local function show_exit_prompt()
	local nodes = {'exit_dialogue_box', 'exit_text', 'yes_exit', 'no_exit', 'yes','no'}	
	for i in ipairs(nodes) do
		local node = gui.get_node(nodes[i])
		gui.set_enabled(node, true)
	end
	local text = gui.get_node('exit_text')
	local node_strings = {'paused', 's_chal', "h_chal",'gold', 'diamonds', "_resume", "_restart", "_sound",
	"_menu", 'resume', 'restart', 'sound', 'menu', 'show_ad', 'ad_text'}
	for i in ipairs(node_strings) do
		local node = gui.get_node(node_strings[i])
		gui.set_enabled(node, false)
	end
	is_exit_prompt_active = true
end

function init(self)
	--animate the exit in the exit prompt
	local exit_text = gui.get_node("exit_text")
	gui.animate(exit_text, 'position.y', 660, gui.EASING_INOUTBOUNCE, 5, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	hide_exit_prompt()
	msg.post("@render:", "clear_color", { color = vmath.vector4(1, 1, 1, 0) } )
	local node_strings = {'resume', "_resume", "restart", "_restart", "sound", 
	"_sound", "menu", "_menu", "s_chal", "h_chal", "gold", "diamonds", "paused",
	"show_ad", "ad_text"}
	get_nodes(node_strings)
	animate_menu(node_table)
	msg.post(".", "acquire_input_focus")
	msg.post("main:/main#challenges", "challenges", {id = "pause:/pause#pause"})
	set_currency()
	if ad_for_hints_played == true then
		gui.set_enabled(gui.get_node('show_ad'), false)
		gui.set_enabled(gui.get_node('ad_text'), false)
	end
end

function final(self)
	msg.post(".", "release_input_focus")
end

local button_tapped = nil

local function handle_input()
	if button_tapped == 'resume' then 
		msg.post(main, 'resume', {col = "pause"})-- tells the controller script which collection to unload when resuming
	elseif button_tapped == 'show_ad' and ad_for_hints_played == false then
		msg.post("main:/main#main", "show_ad", {id = "pause:/pause#pause"})
	elseif button_tapped == 'restart' then
		chances = const_chances
		msg.post(main, 'restart', {col = "pause"})-- tells the controller script which collection to unload when restarting	
	elseif button_tapped == 'sound' then
		msg.post("main:/main#main", "sound")
	elseif button_tapped == 'menu' then
		show_exit_prompt()
	elseif button_tapped == 'yes' then
		chances = const_chances
		msg.post(main, 'return_2_menu', {col = "pause"})-- tells the controller script which collection to unload when returning to menu
	else
		hide_exit_prompt()
	end
end

local function touch_feedback(node)
	local pos = gui.get_position(node)
	gui.animate(node, "position.x", pos.x + 10, gui.EASING_INOUTBOUNCE, BUTTON_ANIMATION_DURATION, 0, handle_input, gui.PLAYBACK_ONCE_PINGPONG)
end

local msg_challenges = hash("challenges")
local msg_completed = hash("completed")

function on_message(self, message_id, message, sender)
	if message_id == msg_challenges then
		local s_chal = gui.get_node("s_chal")
		local h_chal = gui.get_node("h_chal")
		gui.set_text(s_chal, "GOLD CHALLENGE\n"..tostring(message.s))
		gui.set_text(h_chal, "DIAMOND CHALLENGE\n"..tostring(message.h))
	elseif message_id == msg_completed then
		msg.post("level:/controller#controller", "new hints")
		local txt = gui.get_node("ad_text")
		gui.set_text(txt, "Used")
		msg.post(ANALYZER, 'hint_used')
		ad_for_hints_played = true
	end
end

local touch = hash("touch")
local back = hash("back")

function on_input(self, action_id, action)
	if action_id == touch and action.released then
		local _resume  = gui.get_node('_resume')
		local _restart = gui.get_node('_restart')
		local _sound = gui.get_node('_sound')
		local _menu = gui.get_node('_menu')
		local show_ad = gui.get_node('show_ad')
		local yes = gui.get_node("yes_exit")
		local no = gui.get_node("no_exit")
		if gui.pick_node(_resume, action.x, action.y) and is_exit_prompt_active == false then 
			button_tapped = 'resume'
			TouchFb.touch_feedback(_resume, handle_input)
		elseif gui.pick_node(show_ad, action.x, action.y) and is_exit_prompt_active == false then
			button_tapped = 'show_ad'
			TouchFb.touch_feedback(show_ad, handle_input)
		elseif gui.pick_node(_restart, action.x, action.y) and is_exit_prompt_active == false then
			button_tapped = 'restart'
			TouchFb.touch_feedback(_restart, handle_input)
		elseif gui.pick_node(_sound, action.x, action.y) and is_exit_prompt_active == false then
			button_tapped = 'sound'
			TouchFb.touch_feedback(_sound, handle_input)
		elseif gui.pick_node(_menu, action.x, action.y) and is_exit_prompt_active == false then
			button_tapped = 'menu'
			TouchFb.touch_feedback(_menu, handle_input)
		elseif gui.pick_node(yes, action.x, action.y) then
			button_tapped = 'yes'
			TouchFb.touch_feedback(yes, handle_input)
		elseif gui.pick_node(no, action.x, action.y) then
			button_tapped = 'no'
			TouchFb.touch_feedback(no, handle_input)
		end
	elseif action_id == back then
		if is_exit_prompt_active == false then
			button_tapped = 'exit'
			TouchFb.touch_feedback(exit, handle_input)
		else
			hide_exit_prompt()
		end
	end
end